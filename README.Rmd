---
title: "Project 2"
author: "Ipsita Datta & Victoria Seng"
date: "10/15/2021"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, fig.path = "./images/")
```

## Introduction

VICTORIA TODO: describe data set and vars we are working with (target = shares) and mention purpose of analysis methods

I'll add more here once we get a feel for which vars we want to work with and for our models

## Data

```{r libs, echo = FALSE}
#install.packages("Rtools")
library(tidyverse)
library(caret)
library(randomForest)
library(gbm)
library(corrplot)
library(plotrix)
set.seed(300)
```

Importing the data and grabbing a vector of the data channels for later use.

```{r data_import_subset}
newsPop <- read_csv("./Data/OnlineNewsPopularity.csv")
newsChannels <- newsPop %>%
  select(starts_with("data_channel_is_")) %>%
    names
newsChannels
```
Transpose newsPop data to create pie chart across all the data channels
```{r newsPop_TP}
newsPop_TP <- newsPop %>%
  pivot_longer(starts_with("data_channel_is_"), names_to = "dc", values_to = "dcVal") %>%
    filter(dcVal == TRUE) %>%
      mutate(datachannel = substr(dc, 17, nchar(dc))) %>%
        select(datachannel,shares,-dc, -dcVal) 

```

Subsetting the data by the type of data channels :

```{r subset_bus}
bus <- newsPop %>%
  filter(data_channel_is_bus == TRUE) %>%
    select(-starts_with("data_channel_is_"))
```

## Summarizations

TODO: three graphs apiece and "some" summary statistics each. Let's try both doing a contingency table and a couple of summary stats.

I'm going to work with weekday a bit so need to transpose to make it easier to work with.

```{r transpose_weekdays}
TP <- bus %>%
  pivot_longer(starts_with("weekday_is"), names_to = "wd", values_to = "wdVal") %>%
    filter(wdVal == TRUE) %>%
      mutate(weekday = substr(wd, 12, nchar(wd))) %>%
        select(-wd, -wdVal) 
```

This contingency table shows the overall number of shares by weekday. A higher number means more shares have happened on that day.

```{r weekday_contingency}
GDAtools::wtable(TP$weekday, w = TP$shares)
```
Here is the contingency table for best keywords shares by weekdays
```{r weekday_contingency_bestkeyword_shares}
GDAtools::wtable(TP$weekday, w = TP$kw_max_max)
```
Here is contingency table for the number of maximum shares of an article that
was linked in the article by weekday
```{r contingency_self_reference_max}
GDAtools::wtable(TP$weekday, w = TP$self_reference_max_shares)
```
Here are some summary stats by weekday. Again, bigger means more shares.

```{r weekday_summaries}
TP %>%
  group_by(weekday) %>%
    summarize(min = min(shares), mean = mean(shares), median = median(shares), iqr = IQR(shares), max = max(shares))
```
A higher number  means  more best keywords tend to be shared more often by weekday
```{r weekday_summaries_bestKeyword}
TP %>%
  group_by(weekday) %>%
    summarize(min = min(kw_max_max), mean = mean(kw_max_max), median = median(kw_max_max), stddev=sd(kw_max_max),iqr = IQR(kw_max_max), max = max(kw_max_max))
```
Here is the pie chart showing overall which datachannel is doing best
```{r piechart}
df<-newsPop_TP %>% group_by(datachannel) %>% summarise_each(funs(sum))
pct <- round(df$shares/sum(df$shares)*100)
lbls <- paste(df$datachannel, pct) # add percents to labels
lbs<-paste(lbls,"%",sep="")
pie3D(df$shares,labels=lbs,explode=0.1,
   main="Pie Chart of Shares across datachannels ")
```
Here is the bar plot showing bestkeyword shares by weekdays.Heigher means
for bestkeyword shares on that day
```{r bestkeyword_bar}
plot1<-ggplot(TP,aes(x=weekday,y=kw_max_max,fill=weekday))
plot1+ geom_col() + 
  scale_x_discrete("weekday") + 
  ggtitle("bestkeyword shares across weekdays")+
  scale_y_continuous(labels = scales::comma)
```
```{r share_weekdays_bar}
plot2<-ggplot(TP,aes(x=weekday,y=shares,fill=weekday))
plot2+ geom_col() + 
  scale_x_discrete("weekday") + 
  ggtitle(" shares across weekdays")+
  scale_y_continuous(labels = scales::comma)
```

Here is a boxplot of shares by weekend status. I hate how squashed it is and need to find a way to programatically deal with outliers. 

```{r weekend_box}
g <- ggplot(data = bus, aes(x = as_factor(is_weekend), y = shares, group = as_factor(is_weekend)))
g + geom_jitter(aes(color = as_factor(is_weekend))) +
  geom_boxplot() +
      labs(x = "Weekend Status (1 = Weekend, 0 = Weekday)", 
           y = "Number of Shares", 
           title = "Box Plot with Jitter of Shares by Weekend Status") +
        scale_y_continuous(labels = scales::comma, expand = expansion(mult = c(0,0)))
```

Here is a scatter plot of shares vs positive word rate with a grouping on weekday/weekend. The Y axis represents shares. More points higher on the Y axis on the lefthand side of the graph indicate less positive articles getting more shares. More points higher on the Y axis on the righthand side of the graph indicate more positive articles getting more shares. The prevelence of one color over another in any part of the graph is indicative of whether the article was published on a weekday or a weekend.

```{r pos_v_share}
g <- ggplot(data = bus, aes(rate_positive_words, shares))
g + geom_point(aes(color = as_factor(is_weekend)), position = "jitter") + 
  labs(x = "Rate Positive Words", 
       y = "Number of Shares", 
       title = "Positive Word Rate vs Number of Shares by Weekday Status",
       color = "Weekend? (1 = Yes, 0 = No)") + 
    scale_y_continuous(labels = scales::comma)
```
Here is the scatterplot showing number of images vs shares.
From the graph , we can say less number of images have more shares.
Specifically those articles has zero or one image.
```{r images_v_shares}
g <- ggplot(data = bus, aes(num_imgs, shares))
g + geom_point( position = "jitter") + 
  labs(x = "num_imgs", 
       y = "Number of Shares", 
       title = "num_imgs vs Number of Shares "
       ) + 
    scale_y_continuous(labels = scales::comma)
```
Here is a scatter plot of shares vs negative word rate with a grouping on weekday/weekend. The Y axis represents shares. More points higher on the Y axis on the lefthand side of the graph indicate less negative articles getting more shares. Less points higher on the Y axis on the righthand side of the graph indicate more negative articles getting less shares. The prevelence of one color over another in any part of the graph is indicative of whether the article was published on a weekday or a weekend.

```{r negative_words_V_shares_scatterplot}
g1 <- ggplot(data = bus, aes(rate_negative_words, shares))
g1 + geom_point(aes(color = as_factor(is_weekend)), position = "jitter") + 
  labs(x = "negative words rate", 
       y = "Number of Shares", 
       title = "negative words rate vs Number of Shares by Weekend Status",
       color = "Weekend? (1 = Yes, 0 = No)") + 
    scale_y_continuous(labels = scales::comma) 
```
Here is the scatter plot showing poins in the middle has more share as a function of number of words in the title. On Left of the graph with less word in the 
title has less share by weekdays
```{r wordsIntitle}
g2 <- ggplot(data = bus, aes(n_tokens_title, shares))
g2 + geom_point(aes(color = as_factor(is_weekend)), position = "jitter") + 
  labs(x = "Number of words in the title", 
       y = "Number of Shares", 
       title = "Number of words in the title vs Number of Shares by Weekend Status",
       color = "Weekend? (1 = Yes, 0 = No)") + 
    scale_y_continuous(labels = scales::comma) 
```
To find correlation coefficient between shares and other variable,subsetting
dataset with only numeric variables
```{r TP_numeric_correlation}
bus_numeric<-dplyr::select_if(bus,is.numeric)



```
## spliting data in train(70%) and test (30%)
```{r split_data}
Index <- createDataPartition(y =bus$shares , p= 0.7, list = FALSE)
Train <- bus[Index,] %>% select (-url)
Test <- bus[-Index,] %>% select (-url)

```

## Linear Regression Modeling

### Brief explanation of the idea of a linear regression model

A linear regression model describes the relationship between a dependent
variable and one or more independent variables.i.e y=beta0+beta1 * x1+beta2 * x2 +....+betan * xn where y is dependent response variable and x1 to xn 
are independent variable (also called predictors)
Linear models are a way of describing a response variable in terms of a linear 
combination of predictor variables.  

```{r Linear_Regression,echo=FALSE}

lmfit<-train(shares ~ num_hrefs+kw_max_avg+weekday_is_saturday+weekday_is_sunday+
+title_subjectivity+global_sentiment_polarity+LDA_01+LDA_04+rate_positive_words+
num_imgs+num_videos,
             data = Train, 
        method = "lm", 
       preProcess = c("center", "scale"),
      trControl = trainControl(method = "cv", number = 10))
```
Performance on Test data set for Linear Regression model
```{r lm_Test}
pred <- predict(lmfit, newdata =Test)
round(postResample(pred, obs = Test$shares),4)
```
VICTORIA TODO: Fit linear regression and

## Ensemble tree-based modeling
To do an ensemble tree-based model,we created a new column called popularity and add it to the training and test dataset.If the number of shares is greater than 2500, then popularity is equal to 1 (popular) , otherwise 0 (unpopular).
```{r add_binary_column}
Train_glm<- bus_Train %>% 
            mutate(popularity = if_else((shares >= 1500),1,0)) %>%
            select(-shares)
Test_glm<-bus_Test %>%
          mutate(popularity = if_else((shares >= 1500),1,0)) %>%
          select(-shares) 
```
IPSITA TODO:randomforest model
VICTORIA TODO:  boosted tree model

## Comparison

## Automation

Vic note: I'm ok with doing either automation or the comparison, so let me know which one you'd be more comfortable tackling. 